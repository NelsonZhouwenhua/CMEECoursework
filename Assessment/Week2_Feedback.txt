Starting weekly assessment for Wenhua, Week2

Current Points = 100

Note that: 
(1) Major sections begin with a double "====" line 
(2) Subsections begin with a single "====" line 
(3) Code output or text file content are printed within single "*****" lines 

======================================================================
======================================================================
Your Git repo size this week is about 4.00 MiB on disk 

PART 1: Checking project workflow...

Found the following directories in parent directory: Week1, Assessment, Week2, .git

Found the following files in parent directory: README.txt, .gitignore

Checking for key files in parent directory...

Found .gitignore in parent directory, great! 

Printing contents of .gitignore:
**********************************************************************
*~ 
*.tmp
*.tif
**********************************************************************

Found README in parent directory, named: README.txt

Printing contents of README.txt:
**********************************************************************
My CMEE Coursework Repository

Author : Wenhua Zhou (wz2812@ic.ac.uk)

This repository includes all the coursework I have done from the course MRes in Computational Methods in Ecology and Evolution. 

This course begins in October 2019 and ends in September 2020. 

Every week I will update the work I did including the practicals and miniprojects.

Hopefully I can learn more about programming this year, and this repository can also be useful in the future.


**********************************************************************

======================================================================
Looking for the weekly directories...

Found 2 weekly directories: Week1, Week2

The Week2 directory will be assessed 

======================================================================
======================================================================
PART 2: Checking weekly code and workflow...

======================================================================
Assessing WEEK2...

Found the following directories: Code, Data, Sandbox, results

Found the following files: README.txt

Checking for readme file in weekly directory...

Found README in parent directory, named: README.txt

Printing contents of README.txt:
**********************************************************************
Week 2 summary

Author: Wenhua Zhou(wz2812@ic.ac.uk)

Date: 7/10~~13/10

Chapter covered: Biological Computing in Python 1 

Status: chapter covered and practicals done

###############################################################

Chapter 5: Biological Computing in Python 1

Code directory:

basic_io1.py
# python script to open a file and print lines(skip blank lines) in that file

basic_io2.py
# python script to save the elements into a file

basic_io3.py
# python script to store the object for later use and then load into

basic_io.py
# combination of the previous 3 scripts

basic_csv.py
# python script to read data and use it from csv files

cfexercises1.py
# originally a python script containing some functions
# after practicals work, it is modified and the output is evaluated automatically
# the input variables are:
# print(foo_1(10))
# print(foo_2(10,2))
# print(foo_3(30,20,10))
# print(foo_4(10))
# print(foo_5(10))
# print(foo_6(10))

loops.py
# a python script including for loops and while loops examples

cfexercises2.py
# a python script including some loops
# after practicals work, it is modified 
# all loops are changed into functions with input variables set to be original default 

oaks.py
# a python script using for loops and list comprehensions to deal with data

scope.py 
# a python script using examples to introduce properties of global variables

boilerplate.py
# a python script containing an example template for python programs

using_name.py
# a python script to illustrate if a script is run by itself or not

control_flow.py
# a example python script using various control flow tools within a python program

lc1.py
# work for practicals, create lists by for loops and line comprehensions

lc2.py
# work for practicals, create filtered lists by for loops and line comprehensions

dictionary.py
# work for practicals, populate a dictionary with different sets of taxa

tuple.py
# work for practicals, print out tuples in separate lines

test_control_flow
# a python script to test even_or_odd function in control_flow.py 

debugme.py
# a python script with bug to test debugger

align_seqs.py
# work for practical of align DNA sequences
# convert from the original align_seqs.py from repository
# now read csv files including the two example sequences originally given
# and find the best alignment and score

align_seqs_fasta.py
# work for practical of align DNA sequences
# convert from the align_seqs.py but define a function to read sequence in fasta files
# change output as best score only since sequence are too long to compare
# but it can also find the best alignment and score

align_seqs_better.py
# work for practical of align DNA sequences
# change the output so that all best alignments are recorded
# use pickle to record the best alignments into .p file and load again

oaks_debugme.py
# work for missing oaks problem from last practical
# fix the bug of misspelling
# write a doctest to make sure of no bug
# rewrite the is_an_oak function so that only 'quercus' not any genus startswith 'quercus' will be considered as an oak
# remove header when read csv and put header into out put file

Data directory:

testcsv.csv
# test csv file for basic_csv.py script, including sets of data with different species

bodymass.csv
# csv written that only contains species name and body mass

DNA_seq.csv
# csv file with example DNA sequence input for aligning DNA sequences

TestOaksData.csv
# csv data of oaks downloaded

JustOaksData.csv
# output file of oaks_debugme.py from practical**********************************************************************

Found following files in results directory: best_align.p...

Found 24 code files: lc2.py, boilerplate.py, basic_csv.py, cfexercises2.py, align_seqs_better.py, dictionary.py, debugme.py, scope.py, basic_io3.py, cfexercises1.py, tuple.py, basic_io.py, lc1.py, oaks_debugme.py, oaks.py, loops.py, using_name.py, align_seqs.py, basic_io2.py, sysargv.py, align_seqs_fasta.py, control_flow.py, test_control_flow.py, basic_io1.py

======================================================================
Testing script/code files...

======================================================================
Inspecting script file lc2.py...

File contents are:
**********************************************************************
# Average UK Rainfall (mm) for 1910 by month
# http://www.metoffice.gov.uk/climate/uk/datasets
rainfall = (('JAN',111.4),
            ('FEB',126.1),
            ('MAR', 49.9),
            ('APR', 95.3),
            ('MAY', 71.8),
            ('JUN', 70.2),
            ('JUL', 97.1),
            ('AUG',140.2),
            ('SEP', 27.0),
            ('OCT', 89.4),
            ('NOV',128.4),
            ('DEC',142.2),
           )

# (1) Use a list comprehension to create a list of month,rainfall tuples where
# the amount of rain was greater than 100 mm.
month_rainfall_com = [i for i in rainfall if i[1] > 100]
print(month_rainfall_com)

# (2) Use a list comprehension to create a list of just month names where the
# amount of rain was less than 50 mm. 
month_com = [i for i in rainfall if i[1] < 50]
print(month_com)

# (3) Now do (1) and (2) using conventional loops (you can choose to do 
# this before 1 and 2 !).

# list of month and rainfall where rain greater than 100mm
month_rainfall_loop = []
for i in range(len(rainfall)):
    if rainfall[i][1] > 100:
        month_rainfall_loop.append(rainfall[i])
print(month_rainfall_loop)

# list of month where rain less than 50mm
month_loop = []
for i in range(len(rainfall)):
    if rainfall[i][1] < 50:
        month_loop.append(rainfall[i])
print(month_loop)

**********************************************************************

Testing lc2.py...

lc2.py is a Python script file;
 checking for docstrings...

Found no doctrings!
1 pt deducted

Current Points = 99

Output (only first 500 characters): 

**********************************************************************
[('JAN', 111.4), ('FEB', 126.1), ('AUG', 140.2), ('NOV', 128.4), ('DEC', 142.2)]
[('MAR', 49.9), ('SEP', 27.0)]
[('JAN', 111.4), ('FEB', 126.1), ('AUG', 140.2), ('NOV', 128.4), ('DEC', 142.2)]
[('MAR', 49.9), ('SEP', 27.0)]

**********************************************************************

Code ran without errors

Time consumed = 0.04629s

======================================================================
Inspecting script file boilerplate.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

"""Description of this program or application.
    You can use several lines"""

__appname__ = 'boilerplate.py'
__author__ = 'Wenhua Zhou (wz2812@ic.ac.uk)'
__version__ = '0.0.1'
__license__ = "License for this code/program"

## imports ##
import sys # module to interface our program with the operating system

## constants ##


## functions ##
def main(argv):
    """ Main entry point of the program """
    print('This is a boilerplate') # NOTE: indented using two tabs or 4 spaces
    return 0

if __name__ == "__main__": 
    """Makes sure the "main" function is called from command line"""  
    status = main(sys.argv)
    sys.exit(status)
**********************************************************************

Testing boilerplate.py...

boilerplate.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
This is a boilerplate

**********************************************************************

Code ran without errors

Time consumed = 0.03634s

======================================================================
Inspecting script file basic_csv.py...

File contents are:
**********************************************************************
import csv

# Read a file containing:
# 'Species','Infraorder','Family','Distribution','Body mass male (Kg)'
f = open('../Data/testcsv.csv','r')

csvread = csv.reader(f)
temp = []
for row in csvread:
    temp.append(tuple(row))
    print(row)
    print("The species is", row[0])

f.close()

# write a file containing only species name and Body mass
f = open('../Data/testcsv.csv','r')
g = open('../Data/bodymass.csv','w')

csvread = csv.reader(f)
csvwrite = csv.writer(g)
for row in csvread:
    print(row)
    csvwrite.writerow([row[0], row[4]])

f.close()
g.close()
**********************************************************************

Testing basic_csv.py...

basic_csv.py is a Python script file;
 checking for docstrings...

Found no doctrings!
1 pt deducted

Current Points = 98

Output (only first 500 characters): 

**********************************************************************
['Species', 'Infraorder', 'Family', 'Distribution', 'Body mass male (Kg)']
The species is Species
['Daubentonia_madagascariensis', 'Chiromyiformes ', 'Daubentoniidae', 'Madagascar', '2.7']
The species is Daubentonia_madagascariensis
['Allocebus_trichotis', 'Lemuriformes', 'Cheirogaleidae', 'Madagascar', '0.1']
The species is Allocebus_trichotis
['Avahi_laniger', 'Lemuriformes', 'Indridae', 'America', '1.03']
The species is Avahi_laniger
['Avahi_occidentalis', 'Lemuriformes', 'Indridae', 'Madagasc
**********************************************************************

Code ran without errors

Time consumed = 0.03045s

======================================================================
Inspecting script file cfexercises2.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

__author__ = 'Wenhua Zhou(wz2812@ic.ac.uk)'
__version__ = '0.0.1'

import sys

# write functions for all these loops

# print a 'hello' when integer smaller than variable x can be divided by 3
def foo_1(x):
    for j in range(x):
        if j % 3 == 0:
            print('hello')

# print a 'hello' when integer smaller than variable x can be divided by 4 or 5
def foo_2(x):
    for j in range(x):
        if j % 5 == 3:
            print('hello')
        elif j % 4 == 3:
            print('hello')

# print a 'hello' each time and plus 3 for the variable z until z reaches 15
def foo_3(z):
    while z != 15:
        print('hello')
        z = z + 3

# add 1 to the variable z until z reaches 100,
# print 7 'hello's when z = 31, abd print 'hello' when z = 18
def foo_4(z):
    while z < 100:
        if z == 31:
            for k in range(7):
                print('hello')
        elif z == 18:
            print('hello')
        z = z + 1

# test arguments for the functions
def main(argv):
    foo_1(12) # print 4 'hello's
    foo_2(15) # print 5 'hello's
    foo_3(0) # print 5 'hello's
    foo_4(12) # print 8 'hello's
    return 0

if __name__ == "__main__":
    status = main(sys.argv)
    sys.exit(status)**********************************************************************

Testing cfexercises2.py...

cfexercises2.py is a Python script file;
 checking for docstrings...

Found no doctrings!
1 pt deducted

Current Points = 97

Output (only first 500 characters): 

**********************************************************************
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello

**********************************************************************

Code ran without errors

Time consumed = 0.03141s

======================================================================
Inspecting script file align_seqs_better.py...

File contents are:
**********************************************************************
'''change the output so that all best alignments are recorded'''
# load two sequences from the csv in data directory
import csv

f = open('../Data/DNA_seq.csv','r')

# read csv
csvread = csv.reader(f)
temp = []
for row in csvread:
    temp.append(tuple(row))
seq1 = temp[0][0] # put two sequences into seq1 and seq2
seq2 = temp[0][1]   

f.close()

# Assign the longer sequence s1, and the shorter to s2
# l1 is length of the longest, l2 that of the shortest

l1 = len(seq1)
l2 = len(seq2)
if l1 >= l2:
    s1 = seq1
    s2 = seq2
else:
    s1 = seq2
    s2 = seq1
    l1, l2 = l2, l1 # swap the two lengths

# A function that computes a score by returning the number of matches starting
# from arbitrary startpoint (chosen by user)
def calculate_score(s1, s2, l1, l2, startpoint):
    matched = "" # to hold string displaying alignements
    score = 0
    for i in range(l2):
        if (i + startpoint) < l1:
            if s1[i + startpoint] == s2[i]: # if the bases match
                matched = matched + "*"
                score = score + 1
            else:
                matched = matched + "-"

    # some formatted output
    print("." * startpoint + matched)           
    print("." * startpoint + s2)
    print(s1)
    print(score) 
    print(" ")

    return score

# Test the function with some example starting points:
# calculate_score(s1, s2, l1, l2, 0)
# calculate_score(s1, s2, l1, l2, 1)
# calculate_score(s1, s2, l1, l2, 5)

# now try to find the best match (highest score) for the two sequences
my_best_align = []
my_best_score = -1

import pickle
'''use pickle to record the best alignments into .p file and load again'''
for i in range(l1): # Note that you just take the last alignment with the highest score
    z = calculate_score(s1, s2, l1, l2, i)
    if z > my_best_score:
        my_best_align = [] # clean the previous alignments
        my_best_align.append("." * i + s2) # think about what this is doing!
        my_best_score = z 
    elif z == my_best_score:
        my_best_align.append("." * i + s2) # add another alignment if there is a tie

# print all the best alignments and the long sequence with the best score
print("My best alignments are:")
for i in my_best_align:
    print(i)
print("The long sequence:")
print(s1)
print("Best score:", my_best_score)

# put the best alignments into the results directory as best_align.p
f = open('../results/best_align.p','wb')
pickle.dump(my_best_align, f)
f.close()

## Load the data again
f = open('../results/best_align.p','rb')
best_align = pickle.load(f)
f.close()

print(best_align)**********************************************************************

Testing align_seqs_better.py...

align_seqs_better.py is a Python script file;
 checking for docstrings...

Found no doctrings!
1 pt deducted

Current Points = 96

Output (only first 500 characters): 

**********************************************************************
-----*****
CAATTCGGAT
ATCGCCGGATTACGGG
5
 
.------*--*
.CAATTCGGAT
ATCGCCGGATTACGGG
2
 
..*---------
..CAATTCGGAT
ATCGCCGGATTACGGG
1
 
...--------*-
...CAATTCGGAT
ATCGCCGGATTACGGG
1
 
....*---------
....CAATTCGGAT
ATCGCCGGATTACGGG
1
 
.....*---*-----
.....CAATTCGGAT
ATCGCCGGATTACGGG
2
 
......--***--*--
......CAATTCGGAT
ATCGCCGGATTACGGG
4
 
.......-*-*-***-
.......CAATTCGGAT
ATCGCCGGATTACGGG
5
 
........------**
........CAATTCGGAT
ATCGCCGGATTACGGG
2
 
.........--*---*
.........CAATTCGGAT
ATCGCCGG
**********************************************************************

Code ran without errors

Time consumed = 0.03092s

======================================================================
Inspecting script file dictionary.py...

File contents are:
**********************************************************************
taxa = [ ('Myotis lucifugus','Chiroptera'),
         ('Gerbillus henleyi','Rodentia',),
         ('Peromyscus crinitus', 'Rodentia'),
         ('Mus domesticus', 'Rodentia'),
         ('Cleithrionomys rutilus', 'Rodentia'),
         ('Microgale dobsoni', 'Afrosoricida'),
         ('Microgale talazaci', 'Afrosoricida'),
         ('Lyacon pictus', 'Carnivora'),
         ('Arctocephalus gazella', 'Carnivora'),
         ('Canis lupus', 'Carnivora'),
        ]

# Write a short python script to populate a dictionary called taxa_dic 
# derived from  taxa so that it maps order names to sets of taxa. 
# E.g. 'Chiroptera' : set(['Myotis lucifugus']) etc. 

# create the empty string
taxa_dic = {}
# put the sets in taxa into different sets
for i in taxa:
        taxa_dic[i[1]] = set()
# maps the order names to those sets
for i in taxa:
        taxa_dic[i[1]].add(i[0])
print(taxa_dic)        
**********************************************************************

Testing dictionary.py...

dictionary.py is a Python script file;
 checking for docstrings...

Found no doctrings!
1 pt deducted

Current Points = 95

Output (only first 500 characters): 

**********************************************************************
{'Rodentia': {'Cleithrionomys rutilus', 'Mus domesticus', 'Peromyscus crinitus', 'Gerbillus henleyi'}, 'Carnivora': {'Lyacon pictus', 'Arctocephalus gazella', 'Canis lupus'}, 'Afrosoricida': {'Microgale dobsoni', 'Microgale talazaci'}, 'Chiroptera': {'Myotis lucifugus'}}

**********************************************************************

Code ran without errors

Time consumed = 0.02808s

======================================================================
Inspecting script file debugme.py...

File contents are:
**********************************************************************
def createabug(x):
    y = x**4
    z = 0.
    import ipdb; ipdb.set_trace()
    y = y/z
    return y

createabug(25)**********************************************************************

Testing debugme.py...

debugme.py is a Python script file;
 checking for docstrings...

Found no doctrings!
1 pt deducted

Current Points = 94

Output (only first 500 characters): 

**********************************************************************
]0;IPython: Week2/Code> [0;32m/home/mhasoba/Documents/Teaching/IC_CMEE/2019-20/Coursework/StudentRepos/WenhuaZhou_WZ2812/Week2/Code/debugme.py[0m(5)[0;36mcreateabug[0;34m()[0m
[0;32m      3 [0;31m    [0mz[0m [0;34m=[0m [0;36m0.[0m[0;34m[0m[0m
[0m[0;32m      4 [0;31m    [0;32mimport[0m [0mipdb[0m[0;34m;[0m [0mipdb[0m[0;34m.[0m[0mset_trace[0m[0;34m([0m[0;34m)[0m[0;34m[0m[0m
[0m[0;32m----> 5 [0;31m    [0my[0m [0;34m=[0m [0my[0m[0;34m/[0m[0mz[0m[0
**********************************************************************

Code ran without errors

Time consumed = 0.65158s

======================================================================
Inspecting script file scope.py...

File contents are:
**********************************************************************
## Global Block 1 

_a_global = 10 # a global variable

if _a_global > 5:
    _b_global = _a_global + 5 # also a global variable

def a_function():
    _a_global = 5 # a local variable
    
    if _a_global >= 5:
        _b_global = _a_global + 5 # also a local variable
    
    _a_local = 4
    
    print("Inside the function, the value of _a_global is ", _a_global)
    print("Inside the function, the value of _b_global is ", _b_global)
    print("Inside the function, the value of _a_local is ", _a_local)
    
    return None

a_function()

print("Outside the function, the value of _a_global is ", _a_global)
print("Outside the function, the value of _b_global is ", _b_global)




## Global block 2

_a_global = 10

def a_function():
    _a_local = 4
    
    print("Inside the function, the value _a_local is ", _a_local)
    print("Inside the function, the value of _a_global is ", _a_global)
    
    return None

a_function()

print("Outside the function, the value of _a_global is", _a_global)


## Global block 3

_a_global = 10

print("Outside the function, the value of _a_global is", _a_global)

def a_function():
    global _a_global
    _a_global = 5
    _a_local = 4
    
    print("Inside the function, the value of _a_global is ", _a_global)
    print("Inside the function, the value _a_local is ", _a_local)
    
    return None

a_function()

print("Outside the function, the value of _a_global now is", _a_global)


## Global block 4

def a_function():
    _a_global = 10

    def _a_function2():
        global _a_global
        _a_global = 20
    
    print("Before calling a_function, value of _a_global is ", _a_global)

    _a_function2()
    
    print("After calling _a_function2, value of _a_global is ", _a_global)

a_function()

print("The value of a_global in main workspace / namespace is ", _a_global)

## Global block 5

_a_global = 10

def a_function():

    def _a_function2():
        global _a_global
        _a_global = 20
    
    print("Before calling a_function, value of _a_global is ", _a_global)

    _a_function2()
    
    print("After calling _a_function2, value of _a_global is ", _a_global)

a_function()

print("The value of a_global in main workspace / namespace is ", _a_global)


**********************************************************************

Testing scope.py...

scope.py is a Python script file;
 checking for docstrings...

Found no doctrings!
1 pt deducted

Current Points = 93

Output (only first 500 characters): 

**********************************************************************
Inside the function, the value of _a_global is  5
Inside the function, the value of _b_global is  10
Inside the function, the value of _a_local is  4
Outside the function, the value of _a_global is  10
Outside the function, the value of _b_global is  15
Inside the function, the value _a_local is  4
Inside the function, the value of _a_global is  10
Outside the function, the value of _a_global is 10
Outside the function, the value of _a_global is 10
Inside the function, the value of _a_global is  
**********************************************************************

Code ran without errors

Time consumed = 0.03045s

======================================================================
Inspecting script file basic_io3.py...

File contents are:
**********************************************************************
#############################
# STORING OBJECTS
#############################
# To save an object (even complex) for later use
my_dictionary = {"a key": 10, "another key": 11}

import pickle

f = open('../Sandbox/testp.p','wb') ## note the b: accept binary files
pickle.dump(my_dictionary, f)
f.close()

## Load the data again
f = open('../Sandbox/testp.p','rb')
another_dictionary = pickle.load(f)
f.close()

print(another_dictionary)**********************************************************************

Testing basic_io3.py...

basic_io3.py is a Python script file;
 checking for docstrings...

Found no doctrings!
1 pt deducted

Current Points = 92

Output (only first 500 characters): 

**********************************************************************
{'a key': 10, 'another key': 11}

**********************************************************************

Code ran without errors

Time consumed = 0.03267s

======================================================================
Inspecting script file cfexercises1.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

__author__ = 'Wenhua Zhou (wz2812@ic.ac.uk)'
__version__ = '0.0.1'

import sys

# What does each of foo_x do? 
def foo_1(x):
    return x ** 0.5 # calculate root of input variable

def foo_2(x, y):
    if x > y:
        return x
    return y # choose the larger output of two input variables

def foo_3(x, y, z):
    if x > y:
        tmp = y
        y = x
        x = tmp
    if y > z:
        tmp = z
        z = y
        y = tmp
    return [x, y, z] # compare 3 different inputs
# if first is larger than second, swap positions for them
# if second is larger than third, swap positions for them

def foo_4(x):
    result = 1
    for i in range(1, x + 1):
        result = result * i
    return result # calculate the factorial of input

def foo_5(x): # a recursive function that calculates the factorial of x
    if x == 1:
        return 1
    return x * foo_5(x - 1) 

def foo_6(x): # Calculate the factorial of x in a different way
    facto = 1
    while x >= 1:
        facto = facto * x
        x = x - 1
    return facto

def main(argv):
    print(foo_1(10))
    print(foo_2(10,2))
    print(foo_3(30,20,10))
    print(foo_4(10))
    print(foo_5(10))
    print(foo_6(10))
    return 0

if __name__ == '__main__':
    status = main(sys.argv)
    sys.exit(status)**********************************************************************

Testing cfexercises1.py...

cfexercises1.py is a Python script file;
 checking for docstrings...

Found no doctrings!
1 pt deducted

Current Points = 91

Output (only first 500 characters): 

**********************************************************************
3.1622776601683795
10
[20, 10, 30]
3628800
3628800
3628800

**********************************************************************

Code ran without errors

Time consumed = 0.02429s

======================================================================
Inspecting script file tuple.py...

File contents are:
**********************************************************************
birds = ( ('Passerculus sandwichensis','Savannah sparrow',18.7),
          ('Delichon urbica','House martin',19),
          ('Junco phaeonotus','Yellow-eyed junco',19.5),
          ('Junco hyemalis','Dark-eyed junco',19.6),
          ('Tachycineata bicolor','Tree swallow',20.2),
        )

# Birds is a tuple of tuples of length three: latin name, common name, mass.
# write a (short) script to print these on a separate line or output block by species 
# Hints: use the "print" command! You can use list comprehensions!

# use for loop or comprehension to print the tuple into separate lines
for i in birds:
    print ('('+ i[0] + ' , ' + i[1] + ' , ' + str(i[2]) +')'+ '\n') # for loop is used 
    # each line of elements are printed out with commas and newline character**********************************************************************

Testing tuple.py...

tuple.py is a Python script file;
 checking for docstrings...

Found no doctrings!
1 pt deducted

Current Points = 90

Output (only first 500 characters): 

**********************************************************************
(Passerculus sandwichensis , Savannah sparrow , 18.7)

(Delichon urbica , House martin , 19)

(Junco phaeonotus , Yellow-eyed junco , 19.5)

(Junco hyemalis , Dark-eyed junco , 19.6)

(Tachycineata bicolor , Tree swallow , 20.2)


**********************************************************************

Code ran without errors

Time consumed = 0.02707s

======================================================================
Inspecting script file basic_io.py...

File contents are:
**********************************************************************
#############################
# FILE INPUT
#############################
# Open a file for reading
f = open('/home/nelson/Documents/CMEECoursework/Week2/Sandbox/test.txt', 'r')
# use "implicit" for loop:
# if the object is a file, python will cycle over lines
for line in f:
    print(line)

# close the file
f.close()

# Same example, skip blank lines
f = open('/home/nelson/Documents/CMEECoursework/Week2/Sandbox/test.txt', 'r')
for line in f:
    if len(line.strip()) > 0:
        print(line)

f.close()

#############################
# FILE OUTPUT
#############################
# Save the elements of a list to a file
list_to_save = range(100)

f = open('/home/nelson/Documents/CMEECoursework/Week2/Sandbox/testout.txt','w')
for i in list_to_save:
    f.write(str(i) + '\n') ## Add a new line at the end

f.close()

#############################
# STORING OBJECTS
#############################
# To save an object (even complex) for later use
my_dictionary = {"a key": 10, "another key": 11}

import pickle

f = open('/home/nelson/Documents/CMEECoursework/Week2/Sandbox/testp.p','wb') ## note the b: accept binary files
pickle.dump(my_dictionary, f)
f.close()

## Load the data again
f = open('/home/nelson/Documents/CMEECoursework/Week2/Sandbox/testp.p','rb')
another_dictionary = pickle.load(f)
f.close()

print(another_dictionary)**********************************************************************

Testing basic_io.py...

basic_io.py is a Python script file;
 checking for docstrings...

Found no doctrings!
1 pt deducted

Current Points = 89

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Encountered error (or warning):
Traceback (most recent call last):
  File "basic_io.py", line 5, in <module>
    f = open('/home/nelson/Documents/CMEECoursework/Week2/Sandbox/test.txt', 'r')
FileNotFoundError: [Errno 2] No such file or directory: '/home/nelson/Documents/CMEECoursework/Week2/Sandbox/test.txt'

======================================================================
Inspecting script file lc1.py...

File contents are:
**********************************************************************
birds = ( ('Passerculus sandwichensis','Savannah sparrow',18.7),
          ('Delichon urbica','House martin',19),
          ('Junco phaeonotus','Yellow-eyed junco',19.5),
          ('Junco hyemalis','Dark-eyed junco',19.6),
          ('Tachycineata bicolor','Tree swallow',20.2),
         )

#(1) Write three separate list comprehensions that create three different
# lists containing the latin names, common names and mean body masses for
# each species in birds, respectively. 

# latin names
latin_com = [i[0] for i in birds]
print(latin_com)

# common names
common_com = [i[1] for i in birds]
print(common_com)

# mean body masses
masses_com = [i[2] for i in birds]
print(masses_com)

# (2) Now do the same using conventional loops (you can choose to do this 
# before 1 !). 

# latin names
latin_loops = []
for i in range(len(birds)):
    latin_loops.append(birds[i][0])
print(latin_loops)

# common names
common_loops = []
for i in range(len(birds)):
    common_loops.append(birds[i][1])
print(common_loops)

# mean body masses
masses_loops = []
for i in range(len(birds)):
    masses_loops.append(birds[i][2])
print(masses_loops)

**********************************************************************

Testing lc1.py...

lc1.py is a Python script file;
 checking for docstrings...

Found no doctrings!
1 pt deducted

Current Points = 88

Output (only first 500 characters): 

**********************************************************************
['Passerculus sandwichensis', 'Delichon urbica', 'Junco phaeonotus', 'Junco hyemalis', 'Tachycineata bicolor']
['Savannah sparrow', 'House martin', 'Yellow-eyed junco', 'Dark-eyed junco', 'Tree swallow']
[18.7, 19, 19.5, 19.6, 20.2]
['Passerculus sandwichensis', 'Delichon urbica', 'Junco phaeonotus', 'Junco hyemalis', 'Tachycineata bicolor']
['Savannah sparrow', 'House martin', 'Yellow-eyed junco', 'Dark-eyed junco', 'Tree swallow']
[18.7, 19, 19.5, 19.6, 20.2]

**********************************************************************

Code ran without errors

Time consumed = 0.05801s

======================================================================
Inspecting script file oaks_debugme.py...

File contents are:
**********************************************************************
import csv
import sys
import doctest # Import the doctest module

#Define function
def is_an_oak(name):
    """ Returns True if name is starts with 'quercus' 
    Test if function is working.

    >>> is_an_oak('Fagus sylvatica')
    False

    >>> is_an_oak('Quercus')
    True
   
    >>> is_an_oak('Quercus cerris')
    False

    >>> is_an_oak('Quercus12313582345')
    False

    """
    # The script is using .startwith, so the genus with name starts with 'quercus'
    # but now actually 'Quercus' will also be consider as a oak (e.g Quercus12345)
    # return name.lower().startswith('quercus,') # misspelling here in first version
    return bool(name.lower() == 'quercus')
    # since the name we need will return the first genus only from main(argv)
    # we can filter that only genus named 'quercus' will be recorded as an oak

def main(argv): 
    f = open('../Data/TestOaksData.csv','r')
    g = open('../Data/JustOaksData.csv','w')
    taxa = csv.reader(f)
    csvwrite = csv.writer(g)
    headers = next(taxa, None) # skip the header
    if headers:
        csvwrite.writerow(headers) # write header into output file in there is a header
    oaks = set()
    for row in taxa:
        print(row)
        print ("The genus is: ") 
        print(row[0] + '\n')
        # import ipdb; ipdb.set_trace()
        if is_an_oak(row[0]): # we are only use the first colomn genus to compare
            print('FOUND AN OAK!\n')
            csvwrite.writerow([row[0], row[1]])    

    return 0
    
if (__name__ == "__main__"):
    status = main(sys.argv)
    doctest.testmod()   # To run with embedded tests**********************************************************************

Testing oaks_debugme.py...

oaks_debugme.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
['Quercus', ' robur']
The genus is: 
Quercus

FOUND AN OAK!

['Fraxinus', ' excelsior']
The genus is: 
Fraxinus

['Pinus', ' sylvestris']
The genus is: 
Pinus

['Quercus', ' cerris']
The genus is: 
Quercus

FOUND AN OAK!

['Quercus', ' petraea']
The genus is: 
Quercus

FOUND AN OAK!


**********************************************************************

Code ran without errors

Time consumed = 0.10652s

======================================================================
Inspecting script file oaks.py...

File contents are:
**********************************************************************
## Finds just those taxa that are oak trees from a list of species

taxa = [ 'Quercus robur',
         'Fraxinus excelsior',
         'Pinus sylvestris',
         'Quercus cerris',
         'Quercus petraea',
       ]

def is_an_oak(name):
    return name.lower().startswith('quercus ')

##Using for loops
oaks_loops = set()
for species in taxa:
    if is_an_oak(species):
        oaks_loops.add(species)
print(oaks_loops)

##Using list comprehensions   
oaks_lc = set([species for species in taxa if is_an_oak(species)])
print(oaks_lc)

##Get names in UPPER CASE using for loops
oaks_loops = set()
for species in taxa:
    if is_an_oak(species):
        oaks_loops.add(species.upper())
print(oaks_loops)

##Get names in UPPER CASE using list comprehensions
oaks_lc = set([species.upper() for species in taxa if is_an_oak(species)])
print(oaks_lc)**********************************************************************

Testing oaks.py...

oaks.py is a Python script file;
 checking for docstrings...

Found no doctrings!
1 pt deducted

Current Points = 87

Output (only first 500 characters): 

**********************************************************************
{'Quercus cerris', 'Quercus robur', 'Quercus petraea'}
{'Quercus cerris', 'Quercus robur', 'Quercus petraea'}
{'QUERCUS CERRIS', 'QUERCUS PETRAEA', 'QUERCUS ROBUR'}
{'QUERCUS CERRIS', 'QUERCUS PETRAEA', 'QUERCUS ROBUR'}

**********************************************************************

Code ran without errors

Time consumed = 0.04256s

======================================================================
Inspecting script file loops.py...

File contents are:
**********************************************************************
# FOR loops in Python
for i in range(5):
    print(i)

my_list = [0, 2, "geronimo!", 3.0, True, False]
for k in my_list:
    print(k)

total = 0
summands = [0, 1, 11, 111, 1111]
for s in summands:
    total = total + s
    print(total)

# WHILE loops  in Python
z = 0
while z < 100:
    z = z + 1
    print(z)

b = True
while b:
    print("GERONIMO! infinite loop! ctrl+c to stop!")
# ctrl + c to stop!**********************************************************************

Testing loops.py...

loops.py is a Python script file;
 checking for docstrings...

Found no doctrings!
1 pt deducted

Current Points = 86

Output (only first 500 characters): 

**********************************************************************
0
1
2
3
4
0
2
geronimo!
3.0
True
False
0
1
12
123
1234
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
GERONIMO! infinite loop! ctrl+c to stop!
GERONIMO! infinite loop! ctrl+c to stop!
GERONIMO! infinite loop! ctrl+c to stop!
GERONIMO! infinite loop! ctrl+c
**********************************************************************

Code ran without errors

Time consumed = 10.37467s

======================================================================
Inspecting script file using_name.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
# Filename: using_name.py

if __name__ == '__main__':
    print('This program is being run by itself')
else:
    print('I am being imported from another module')**********************************************************************

Testing using_name.py...

using_name.py is a Python script file;
 checking for docstrings...

Found no doctrings!
1 pt deducted

Current Points = 85

Output (only first 500 characters): 

**********************************************************************
This program is being run by itself

**********************************************************************

Code ran without errors

Time consumed = 0.07982s

======================================================================
Inspecting script file align_seqs.py...

File contents are:
**********************************************************************
# load two sequences from the csv in data directory
import csv

f = open('../Data/DNA_seq.csv','r')

# read csv
csvread = csv.reader(f)
temp = []
for row in csvread:
    temp.append(tuple(row))
seq1 = temp[0][0] # put two sequences into seq1 and seq2
seq2 = temp[0][1]   

f.close()

# Assign the longer sequence s1, and the shorter to s2
# l1 is length of the longest, l2 that of the shortest

l1 = len(seq1)
l2 = len(seq2)
if l1 >= l2:
    s1 = seq1
    s2 = seq2
else:
    s1 = seq2
    s2 = seq1
    l1, l2 = l2, l1 # swap the two lengths

# A function that computes a score by returning the number of matches starting
# from arbitrary startpoint (chosen by user)
def calculate_score(s1, s2, l1, l2, startpoint):
    matched = "" # to hold string displaying alignements
    score = 0
    for i in range(l2):
        if (i + startpoint) < l1:
            if s1[i + startpoint] == s2[i]: # if the bases match
                matched = matched + "*"
                score = score + 1
            else:
                matched = matched + "-"

    # some formatted output
    print("." * startpoint + matched)           
    print("." * startpoint + s2)
    print(s1)
    print(score) 
    print(" ")

    return score

# Test the function with some example starting points:
# calculate_score(s1, s2, l1, l2, 0)
# calculate_score(s1, s2, l1, l2, 1)
# calculate_score(s1, s2, l1, l2, 5)

# now try to find the best match (highest score) for the two sequences
my_best_align = None
my_best_score = -1

for i in range(l1): # Note that you just take the last alignment with the highest score
    z = calculate_score(s1, s2, l1, l2, i)
    if z > my_best_score:
        my_best_align = "." * i + s2 # use dots to match the position of alignment with the longer sequence
        my_best_score = z 

# print the best alignment and longer sequence
print(my_best_align)
print(s1)
print("Best score:", my_best_score)
**********************************************************************

Testing align_seqs.py...

align_seqs.py is a Python script file;
 checking for docstrings...

Found no doctrings!
1 pt deducted

Current Points = 84

Output (only first 500 characters): 

**********************************************************************
-----*****
CAATTCGGAT
ATCGCCGGATTACGGG
5
 
.------*--*
.CAATTCGGAT
ATCGCCGGATTACGGG
2
 
..*---------
..CAATTCGGAT
ATCGCCGGATTACGGG
1
 
...--------*-
...CAATTCGGAT
ATCGCCGGATTACGGG
1
 
....*---------
....CAATTCGGAT
ATCGCCGGATTACGGG
1
 
.....*---*-----
.....CAATTCGGAT
ATCGCCGGATTACGGG
2
 
......--***--*--
......CAATTCGGAT
ATCGCCGGATTACGGG
4
 
.......-*-*-***-
.......CAATTCGGAT
ATCGCCGGATTACGGG
5
 
........------**
........CAATTCGGAT
ATCGCCGGATTACGGG
2
 
.........--*---*
.........CAATTCGGAT
ATCGCCGG
**********************************************************************

Code ran without errors

Time consumed = 0.04666s

======================================================================
Inspecting script file basic_io2.py...

File contents are:
**********************************************************************
#############################
# FILE OUTPUT
#############################
# Save the elements of a list to a file
list_to_save = range(100)

f = open('../Sandbox/testout.txt','w')
for i in list_to_save:
    f.write(str(i) + '\n') ## Add a new line at the end
f.close()**********************************************************************

Testing basic_io2.py...

basic_io2.py is a Python script file;
 checking for docstrings...

Found no doctrings!
1 pt deducted

Current Points = 83

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 0.04358s

======================================================================
Inspecting script file sysargv.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

import sys
print("This is the name of the script: ", sys.argv[0])
print("Number of arguments: ", len(sys.argv))
print("The arguments are: " , str(sys.argv))**********************************************************************

Testing sysargv.py...

sysargv.py is a Python script file;
 checking for docstrings...

Found no doctrings!
1 pt deducted

Current Points = 82

Output (only first 500 characters): 

**********************************************************************
This is the name of the script:  sysargv.py
Number of arguments:  1
The arguments are:  ['sysargv.py']

**********************************************************************

Code ran without errors

Time consumed = 0.04476s

======================================================================
Inspecting script file align_seqs_fasta.py...

File contents are:
**********************************************************************
import sys

# define a function to read two sequences from separate fasta files 
def read_fasta(f):
    seq = []
    # forloop through the lines to output the sequence only
    for line in f:
        if not line.startswith(">"):
            seq.append(line.replace('\n','')) # remove newline characters
    combine_seq = ''.join(seq) # combine the list together to a sequence
    f.close()
    return(combine_seq)

# import two fasta files from command line
if len(sys.argv) == 3:
    f1 = open(sys.argv[1])
    f2 = open(sys.argv[2])
elif len(sys.argv) == 1: # if no input is given
    f1 = open('../../Week1/Data/407228326.fasta')
    f2 = open('../../Week1/Data/407228412.fasta')

# use read_fasta to load as sequence
seq1 = read_fasta(f1)
seq2 = read_fasta(f2)

# Assign the longer sequence s1, and the shorter to s2
# l1 is length of the longest, l2 that of the shortest

l1 = len(seq1)
l2 = len(seq2)
if l1 >= l2:
    s1 = seq1
    s2 = seq2
else:
    s1 = seq2
    s2 = seq1
    l1, l2 = l2, l1 # swap the two lengths

# A function that computes a score by returning the number of matches starting
# from arbitrary startpoint (chosen by user)
def calculate_score(s1, s2, l1, l2, startpoint):
    matched = "" # to hold string displaying alignements
    score = 0
    for i in range(l2):
        if (i + startpoint) < l1:
            if s1[i + startpoint] == s2[i]: # if the bases match
                matched = matched + "*"
                score = score + 1
            else:
                matched = matched + "-"

    # some formatted output
    # not necessary to print these in the functions if we only want the results
    # print("." * startpoint + matched)           
    # print("." * startpoint + s2)
    # print(s1)
    # print(score) 
    # print(" ")

    return score


# now try to find the best match (highest score) for the two sequences
my_best_align = None
my_best_score = -1

for i in range(l1): # Note that you just take the last alignment with the highest score
    z = calculate_score(s1, s2, l1, l2, i)
    if z > my_best_score:
        my_best_align = "." * i + s2 # think about what this is doing!
        my_best_score = z 

# no need to print best alignment and s1 cause they are too long!
# print(my_best_align)
# print(s1)

# print best score only is good enough
print("Best score:", my_best_score)
**********************************************************************

Testing align_seqs_fasta.py...

align_seqs_fasta.py is a Python script file;
 checking for docstrings...

Found no doctrings!
1 pt deducted

Current Points = 81

Output (only first 500 characters): 

**********************************************************************
Best score: 545

**********************************************************************

Code ran without errors

Time consumed = 4.97045s

======================================================================
Inspecting script file control_flow.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

"""Some functions exemplifying the use of control statements"""
#docstrings are considered part of the running code (normal comments are
#stripped). Hence, you can access your docstrings at run time.
__author__ = 'Wenhua Zhou (wz2812@ic.ac.uk)'
__version__ = '0.0.1'

import sys

def even_or_odd(x=0): # if not specified, x should take value 0.

    """Find whether a number x is even or odd."""
    if x % 2 == 0: #The conditional if
        return "%d is Even!" % x
    return "%d is Odd!" % x

def largest_divisor_five(x=120):
    """Find which is the largest divisor of x among 2,3,4,5."""
    largest = 0
    if x % 5 == 0:
        largest = 5
    elif x % 4 == 0: #means "else, if"
        largest = 4
    elif x % 3 == 0:
        largest = 3
    elif x % 2 == 0:
        largest = 2
    else: # When all other (if, elif) conditions are not met
        return "No divisor found for %d!" % x # Each function can return a value or a variable.
    return "The largest divisor of %d is %d" % (x, largest)

def is_prime(x=70):
    """Find whether an integer is prime."""
    for i in range(2, x): #  "range" returns a sequence of integers
        if x % i == 0:
          print("%d is not a prime: %d is a divisor" % (x, i)) 
          return False
    print("%d is a prime!" % x)
    return True 

def find_all_primes(x=22):
    """Find all the primes up to x"""
    allprimes = []
    for i in range(2, x + 1):
      if is_prime(i):
        allprimes.append(i)
    print("There are %d primes between 2 and %d" % (len(allprimes), x))
    return allprimes

def main(argv):
    print(even_or_odd(22))
    print(even_or_odd(33))
    print(largest_divisor_five(120))
    print(largest_divisor_five(121))
    print(is_prime(60))
    print(is_prime(59))
    print(find_all_primes(100))
    return 0

if __name__ == "__main__": 
    """Makes sure the "main" function is called from command line"""  
    status = main(sys.argv)
    sys.exit(status)
**********************************************************************

Testing control_flow.py...

control_flow.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
22 is Even!
33 is Odd!
The largest divisor of 120 is 5
No divisor found for 121!
60 is not a prime: 2 is a divisor
False
59 is a prime!
True
2 is a prime!
3 is a prime!
4 is not a prime: 2 is a divisor
5 is a prime!
6 is not a prime: 2 is a divisor
7 is a prime!
8 is not a prime: 2 is a divisor
9 is not a prime: 3 is a divisor
10 is not a prime: 2 is a divisor
11 is a prime!
12 is not a prime: 2 is a divisor
13 is a prime!
14 is not a prime: 2 is a divisor
15 is not a prime: 3 is a divisor
16 is 
**********************************************************************

Code ran without errors

Time consumed = 0.02596s

======================================================================
Inspecting script file test_control_flow.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

"""Some functions exemplifying the use of control statements"""

__author__ = 'Your Name (Your.Name@your.email.address)'
__version__ = '0.0.1'

import sys
import doctest # Import the doctest module

def even_or_odd(x=0):
    """Find whether a number x is even or odd.

    >>> even_or_odd(10)
    '10 is Even!'

    >>> even_or_odd(5)
    '5 is Odd!'

    whenever a float is provided, then the closest integer is used:    
    >>> even_or_odd(3.2)
    '3 is Odd!'

    in case of negative numbers, the positive is taken:    
    >>> even_or_odd(-2)
    '-2 is Even!'

    """
    #Define function to be tested
    if x % 2 == 0:
        return "%d is Even!" % x
    return "%d is Odd!" % x

####### I SUPPRESSED THIS BLOCK: WHY? #######
# suppressed this block the function defined in this file is only even_or_odd
# so print other function will cause error

# def main(argv): 
#     print even_or_odd(22)
#     print even_or_odd(33)
#     return 0

# if (__name__ == "__main__"):
#     status = main(sys.argv)
############################################

doctest.testmod()   # To run with embedded tests**********************************************************************

Testing test_control_flow.py...

test_control_flow.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 0.10533s

======================================================================
Inspecting script file basic_io1.py...

File contents are:
**********************************************************************
#############################
# FILE INPUT
#############################
# Open a file for reading
f = open('../Sandbox/test.txt', 'r')
# use "implicit" for loop:
# if the object is a file, python will cycle over lines
for line in f:
    print(line)

# close the file
f.close()

# Same example, skip blank lines
f = open('../Sandbox/test.txt', 'r')
for line in f:
    if len(line.strip()) > 0:
        print(line)

f.close()**********************************************************************

Testing basic_io1.py...

basic_io1.py is a Python script file;
 checking for docstrings...

Found no doctrings!
1 pt deducted

Current Points = 80

Output (only first 500 characters): 

**********************************************************************
First Line

Second Line



Third Line



Fourth Line
First Line

Second Line

Third Line

Fourth Line

**********************************************************************

Code ran without errors

Time consumed = 0.05395s

======================================================================
======================================================================
Finished running scripts

Ran into 1 errors

======================================================================
======================================================================

FINISHED WEEKLY ASSESSMENT

Current Points for the Week = 80

NOTE THAT THESE ARE POINTS, NOT MARKS FOR THE WEEK!